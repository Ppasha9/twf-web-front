import {
  TaskSetConstructorInputs,
  TaskSetConstructorReceivedForm,
  TaskSetConstructorSendForm,
} from "./task-set-constructor.types";
import {
  convertMathInput,
  MathInputFormat,
} from "../../utils/kotlin-lib-functions";
import {
  ExpressionInput,
  TaskConstructorInputs,
  TaskConstructorReceivedForm
} from "../task-constructor/task-constructor.types";
import { RuleConstructorReceivedForm, RuleConstructorInputs, RuleConstructorSendForm } from "../rule-constructor/rule-constructor.types";
import { convertInputStringListSeparatedByCommasToArray } from "../../redux/constructor-jsons/constructor-jsons.utils";
import { RulePackLink } from "../rule-pack-constructor/rule-pack-constructor.types";

class TaskSetConstructorFormatter {
  public static convertReceivedFormToConstructorInputs(
    data: TaskSetConstructorReceivedForm
  ): TaskSetConstructorInputs {
    // @ts-ignore
    return {
      ...data,
      tasks: data.tasks.map((task: TaskConstructorReceivedForm) => {
        const taskCopy: TaskConstructorInputs = { ...task, rulePacks: [] };

        // format expression inputs
        taskCopy.originalExpression = {
          format: MathInputFormat.TEX,
          expression: task.originalExpressionTex,
        };

        taskCopy.goalExpression = {
          format: MathInputFormat.TEX,
          expression: task.goalExpressionTex,
        };

        taskCopy.rulePacks = task.rulePacks.map(
          (rulePack: any) => rulePack.rulePackCode
        );

        taskCopy.taskCreationType = taskCopy.countOfAutoGeneratedTasks > 0 ? "auto" : "manual";

        if (taskCopy.rules) {
          taskCopy.rules = taskCopy.rules.map((rule: RuleConstructorReceivedForm) => {
            const formattedRule: RuleConstructorInputs = { ...rule };
            return formattedRule;
          });
        }

        return taskCopy;
      }),
    };
  }

  public static convertConstructorInputsToSendForm(
    data: TaskSetConstructorInputs
  ): TaskSetConstructorSendForm {
    let res = {
      ...data,
      tasks: []
    } as TaskSetConstructorSendForm;
    if (data.tasks) {
      res.tasks = data.tasks.map((task: TaskConstructorInputs) => {
        const taskCopy: TaskConstructorReceivedForm = {
          ...task,
          originalExpressionPlainText: "",
          originalExpressionTex: "",
          originalExpressionStructureString: "",
          goalExpressionPlainText: "",
          goalExpressionTex: "",
          goalExpressionStructureString: "",
          rulePacks: [],
        };
        taskCopy.namespaceCode = data.namespaceCode;

        if (taskCopy.originalExpression.format === MathInputFormat.TEX) {
          taskCopy.originalExpressionTex = taskCopy.originalExpression.expression;
          taskCopy.originalExpressionPlainText = convertMathInput(
            MathInputFormat.TEX,
            MathInputFormat.PLAIN_TEXT,
            taskCopy.originalExpression.expression
          );
          taskCopy.originalExpressionStructureString = convertMathInput(
            MathInputFormat.TEX,
            MathInputFormat.STRUCTURE_STRING,
            taskCopy.originalExpression.expression
          );
        } else if (taskCopy.originalExpression.format === MathInputFormat.PLAIN_TEXT) {
          taskCopy.originalExpressionPlainText = taskCopy.originalExpression.expression;
          taskCopy.originalExpressionTex = convertMathInput(
            MathInputFormat.PLAIN_TEXT,
            MathInputFormat.TEX,
            taskCopy.originalExpression.expression
          );
          taskCopy.originalExpressionStructureString = convertMathInput(
            MathInputFormat.PLAIN_TEXT,
            MathInputFormat.STRUCTURE_STRING,
            taskCopy.originalExpression.expression
          );
        } else if (taskCopy.originalExpression.format === MathInputFormat.STRUCTURE_STRING) {
          taskCopy.originalExpressionStructureString = taskCopy.originalExpression.expression;
          taskCopy.originalExpressionPlainText = convertMathInput(
            MathInputFormat.STRUCTURE_STRING,
            MathInputFormat.PLAIN_TEXT,
            taskCopy.originalExpression.expression
          );
          taskCopy.originalExpressionTex = convertMathInput(
            MathInputFormat.STRUCTURE_STRING,
            MathInputFormat.TEX,
            taskCopy.originalExpression.expression
          );
        }

        if (taskCopy.goalExpression != null) {
          if (taskCopy.goalExpression.format === MathInputFormat.TEX) {
            taskCopy.goalExpressionTex = taskCopy.goalExpression.expression;
            taskCopy.goalExpressionPlainText = convertMathInput(
                MathInputFormat.TEX,
                MathInputFormat.PLAIN_TEXT,
                task.goalExpression.expression
            );
            taskCopy.goalExpressionStructureString = convertMathInput(
                MathInputFormat.TEX,
                MathInputFormat.STRUCTURE_STRING,
                taskCopy.goalExpression.expression
            );
          } else if (taskCopy.goalExpression.format === MathInputFormat.PLAIN_TEXT) {
            taskCopy.goalExpressionPlainText = taskCopy.goalExpression.expression;
            taskCopy.goalExpressionTex = convertMathInput(
                MathInputFormat.PLAIN_TEXT,
                MathInputFormat.TEX,
                taskCopy.goalExpression.expression
            );
            taskCopy.goalExpressionStructureString = convertMathInput(
                MathInputFormat.PLAIN_TEXT,
                MathInputFormat.STRUCTURE_STRING,
                taskCopy.goalExpression.expression
            );
          } else if (taskCopy.goalExpression.format === MathInputFormat.STRUCTURE_STRING) {
            taskCopy.goalExpressionStructureString = taskCopy.goalExpression.expression;
            taskCopy.goalExpressionPlainText = convertMathInput(
                MathInputFormat.STRUCTURE_STRING,
                MathInputFormat.PLAIN_TEXT,
                taskCopy.goalExpression.expression
            );
            taskCopy.goalExpressionTex = convertMathInput(
                MathInputFormat.STRUCTURE_STRING,
                MathInputFormat.TEX,
                taskCopy.goalExpression.expression
            );
          }
        }

        if (task.rulePacks !== "") {
          taskCopy.rulePacks = convertInputStringListSeparatedByCommasToArray(
              task.rulePacks
          ).map((rulePackCode: string) => {
            return {
              rulePackCode: rulePackCode,
              namespaceCode: taskCopy.namespaceCode,
            } as RulePackLink;
          });
        }

        [
          "otherGoalData",
          "otherCheckSolutionData",
          "otherAwardData",
          "otherAutoGenerationData",
          "otherData",
          "nextRecommendedTasks",
          "solutionsStepsTree",
          "interestingFacts",
          "hints",
        ].forEach((key: string) => {
          if ((task as any)[key] === "") {
            (taskCopy as any)[key] = null;
          }
        });

        if (task.rules) {
          taskCopy.rules = task.rules.map((rule: RuleConstructorInputs) => {
            const formattedRule: RuleConstructorSendForm = { ...rule };

            if (!rule.left && !rule.right) {
              return formattedRule;
            }

            // @ts-ignore
            const left = rule.left as ExpressionInput;
            formattedRule.leftStructureString = convertMathInput(
                left.format,
                MathInputFormat.STRUCTURE_STRING,
                rule.left!!.expression
            );
            // @ts-ignore
            const right = rule.right as ExpressionInput;
            formattedRule.rightStructureString = convertMathInput(
                right.format,
                MathInputFormat.STRUCTURE_STRING,
                rule.right!!.expression
            );
            return formattedRule;
          });
        }
        return taskCopy
      });
    }

    if (!res.otherData) {
      res.otherData = null;
    }

    console.log(res);
    // @ts-ignore
    return res;
  }
}

export default TaskSetConstructorFormatter;
